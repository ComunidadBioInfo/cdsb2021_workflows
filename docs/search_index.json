[["index.html", "Workshop CDSB 2021: Flujos de trabajo con RStudio y creación de Shiny apps Bienvenida 0.1 Instructores 0.2 Ponentes invitados 0.3 Temario 0.4 Patrocinadores 0.5 Licencia", " Workshop CDSB 2021: Flujos de trabajo con RStudio y creación de Shiny apps Joselyn Chávez, Erick Cuevas-Fernández, Alejandro Reyes, Alejandra Medina-Rivera, María Teresa Ortiz, Mirna Vázquez Rosas-Landa, Aurora Labastida, Ángel Escalante, Alejandro Ponce. Bienvenida Bienvenidos al Workshop Flujos de trabajo con RStudio y creación de Shiny apps! En este taller haremos un recorrido por las configuraciones avanzadas de RStudio y te hablaremos sobre las buenas prácticas para organizar tu código en proyectos de RStudio. Además, te mostraremos cómo trabajar en proyectos colaborativos usando control de versiones y cómo resolver conflictos al trabajar en este tipo de proyectos. Finalizaremos con un recorrido introductorio sobre las aplicaciones de Shiny y te mostraremos cómo crear tu primera aplicación. Todas las sesiones serán teóricas y prácticas. Nos enfocaremos en tres temas principales: Manejo de proyectos de RStudio. Control de versiones con GitHub. Creación de Shiny apps. 0.1 Instructores M.C. Joselyn Chávez M.C. Erick Cuevas-Fernández Dr. Alejandro Reyes Dra. Alejandra Medina-Rivera M.C. María Teresa Ortiz Dra. Mirna Vázquez Rosas-Landa M.C. Aurora Labastida 0.2 Ponentes invitados Dra. Ana Beatriz Villaseñor Altamirano Lic. Ángel Escalante Dr. Alejandro Ponce 0.3 Temario Consulta el calendario de este curso en: http://bit.ly/calendarcdsb2021 0.3.1 Lunes 9 de agosto Horario Tema Instructor 10:00-11:00 Hacks de RStudio Erick Cuevas Fernández 11:30-13:00 Flujo de trabajo con proyectos de RStudio Joselyn Chávez 13:00-14:00 Generando mi primer proyecto de RStudio Joselyn Chávez 15:00-16:00 Trabajando con paths seguros María Teresa Ortiz 16:00-17:00 Buenas prácticas para nombrar archivos María Teresa Ortiz 16:00-17:00 Buenas prácticas para nombrar archivos María Teresa Ortiz 17:00-17:50 Principios FAIR para software de investigación Paula Andrea 0.3.2 Martes 10 de agosto Horario Tema Instructor 9:00-10:00 Introducción a Git y GitHub desde terminal Mirna Vázquez Rosas-Landa 10:00-11:00 Generando un proyecto colaborativo con Git/GitHub Aurora Labastida 11:30-12:00 Keynote: La comunidad R-Ladies Ana Beatriz Villaseñor Altamirano 12:00-14:00 Git y GitHub con RStudio Erick Cuevas Fernández 15:30-17:30 Merge y conflictos de versiones en Git y GitHub Alejandra Medina Rivera 0.3.3 Miércoles 11 de agosto Horario Tema Instructor 9:00-10:30 Modificando los archivos de inicio de R Joselyn Chávez 11:30-12:30 Keynote Código legible con R: buenas prácticas de escritura Ángel Escalante 15:30-16:30 Mantenimiento del espacio de trabajo Joselyn Chávez 16:30-17:30 Instalación de paqueterías desde código fuente Joselyn Chávez 0.3.4 Jueves 12 de agosto Horario Tema Instructor 9:00-11:00 Introducción a Shiny Erick Cuevas Fernández 11:30-14:00 Creando mi primera aplicación de Shiny Alejandro Reyes 15:30-17:30 Proyecto colaborativo Alejandro Reyes, Erick Cuevas Fernández, Joselyn Chávez 0.3.5 Viernes 13 de agosto Horario Tema Instructor 9:00-11:00 Proyecto colaborativo Alejandro Reyes, Erick Cuevas Fernández, Joselyn Chávez 11:30-12:30 Keynote: Aplicaciones ShinyR en la vida diaria Alejandro Ponce 12:30-14:00 Proyecto colaborativo Alejandro Reyes, Erick Cuevas Fernández, Joselyn Chávez 15:30-17:00 Presentación de proyectos Alejandro Reyes, Erick Cuevas Fernández, Joselyn Chávez 0.4 Patrocinadores Agradecemos a nuestros patrocinadores: 0.5 Licencia Este material posee una licencia tipo Creative Commons Attribution-ShareAlike 4.0 International License. Para conocer más sobre esta licencia, visite http://creativecommons.org/licenses/by-sa/4.0/ Este material está basado en: RStudioConf2020 workshop What They Forgot. El material de Happy Git with R. El libro Mastering Shiny "],["rstudio-hacks.html", "1 RStudio hacks 1.1 Inicio 1.2 Misión de RStudio 1.3 Equipo de RStudio 1.4 Historia de RStudio 1.5 Primeros consejos para iniciar 1.6 La interfaz gráfica de RStudio 1.7 Atajos con el teclado en RStudio 1.8 Archivos de RStudio 1.9 Trabajando con el Environment 1.10 Últimos tips", " 1 RStudio hacks Erick Cuevas Fernández 9 de agosto de 2021 1.1 Inicio Para poder usar RStudio tenemos que tener instalado R en nuestras máquinas. Si aún no lo has instalado lo puedes descargar desde el siguiente link https://cran.itam.mx. Asegúrate de tener la versión más reciente. También necesitas descargar la versión más reciente de RStudio Desktop. (1.4.1717). 1.2 Misión de RStudio “La misión de RStudio es crear software gratuito y de código abierto para ciencia de datos, investigación científica y comunicación técnica. Hacemos esto para mejorar la producción y el consumo de conocimiento por parte de todos, independientemente de los medios económicos, y para facilitar la colaboración y la investigación reproducible, las cuales son críticas” 1.3 Equipo de RStudio “Las personas que se han unido a RStudio en este viaje son extraordinarias. Incluyen un número excepcional de los científicos de datos y desarrolladores de software de código abierto más productivos y respetados del mundo.” 1.4 Historia de RStudio 1.5 Primeros consejos para iniciar Al abrir RStudio la consola nos arroja el mensaje que se muestra a continuación en la imagen. En este mensaje nos indica la versión de R que tenemos instalada y la plataforma en la que estamos trabajando. Para citar R en alguna publicación basta con usar la función citation(). Y para conocer a todo el equipo detrás del desarrollo de R, puedes consultarlo con la función contributors(). R y RStudio están diseñados para que muchas personas puedan aprenderlo desde cero, con tan solo este primer mensaje todo usuario podría empezar a aprender R; para empezar a aprender R intenta usar la función en tu consola de help.start() con el cual se desplegará un menú en HTML con todos los manuales para aprender a usar R, también aparecerán los manuales de todas las paqueterías del repositorio de CRAN (The Comprehensive R archive Network) así como enlaces a noticias del mundo de R. Otro consejo útil al momento de iniciar con el uso de una paquetería o función en particular es ejecutar la función demo(). Esta función se puede utilizar con los siguientes argumentos. demo(topic, package = NULL, lib.loc = NULL, character.only = FALSE, verbose = getOption(&quot;verbose&quot;), echo = TRUE, ask = getOption(&quot;demo.ask&quot;), encoding = getOption(&quot;encoding&quot;)) Para desplegar todos las demostraciones disponibles ejecuta la función como se muestra a continuación: demo(package = .packages(all.available = TRUE)) 1.6 La interfaz gráfica de RStudio RStudio es un entorno de desarrollo integrado (IDE) para R. Su interfaz gráfica incluye 3 paneles principales: Consola de R Datos en el ambiente, Historial, Conecciones remotas, Git. Gráficos, Archivos, Ayuda, Paqueterías. 1.6.1 Opciones Globales… Las opciones globales (Global Options…) nos permitirán cambiar aspectos visuales de la organización de la interfaz gráfica. Para acceder a estas opciones debemos ir a Tools | Global Options... o usar directamente el atajo de teclado command + , (Mac) ó ctrl + , (Linux y Windows). Una vez accesando a las Opciones Globales podemos modificar que no se gaste memoria temporal al guardar datos o código de sesiones anteriores en la parte de General. Al quitar las “palomitas” de los pequeños cuadros de las opciones generales señaladas en los recuadros azules. Dentro de las Opciones Globales podemos modificar nuestros atajos de teclado, el tamaño de la indentación, margenes de código, etc, etc. Una función atractivamente visual al momento de escribir código, sobre todo en funciones y para hacer sub conjuntos de nuestros datos, es Parentesis de Arcoíris. Esta es una nueva función en esta nueva versión de RStudio. Para habilitarla debemos dentro de las Opciones Globales debemos acceder a Code | Display y marcar la “palomita” en Rainbow parentheses. En la se sección de Apariencia, esta opción podemos definir el color, letra y tamaño de nuestro editor de código. De esta manera personalizarlo a nuestras necesidades o gustos. También podemos modificar el diseño de los paneles en Pane Layout, en la nueva versión de RStudio podemos visualizar dos editores de código al mismo tiempo. Al hcer click en Add column. En esta sección podemos modificar la distribución de los paneles y el contenido de ellos. 1.6.2 Actividad Realiza los cambios necesarios en tus Opciones Globales para que no se guarde el proyecto más reciente ni los datos en el ambiente de RStudio, así como la .RData Habilita los paréntesis de arcoíris. Cambia el tema de tu RStudio al de Dracula y usa la letra y el tamaño que más prefieras. 1.7 Atajos con el teclado en RStudio NOTA: en windows en vez de command usa control %&gt;% : command + Shift + m Para comentar código: command + Shift + c Expandir cursor: mantén presionado Alt + usa el cursor Ejecutar en la terminal líena de código y saltar a la siguiente línea de código: command + Enter Ejecutar en la terminal línea de código y mantenerse en la línea de código: Alt + Enter Compilar en reporte pdf: Shift + command + k 1.8 Archivos de RStudio En RStudio podemos generar todos los archivos enlístados en “New File”. El archivo más usado para desarrollar código en R es “R Script”. Aún así RStudio nos permite hacer reportes de nuestros código con “R Notebook y R Markdown”, aplicaciones web con “Shiny Web App”, generar APIs con “Plumber API”, editar código en HTML, C, C++, Python, CSS, JavaScript, Shell, entre otros. Más adelante verás cómo optimizar tu trabajo trabajando con RProject en RStudio. 1.9 Trabajando con el Environment 1.9.1 Actividad Crea dos R scripts. Agrega una nueva columna en la visualización de los Scripts dentro de Opciones Globales. En un script ejecuta el siguiente código: install.packages(&quot;MASS&quot;) library(MASS) data(cats) View(cats) table(cats$Sex) PAUSA ¿Qué sucede al ejecutar data(cats) y View(cats)? ¿Qué formas hay desde la interfaz gráfica para importar datos? En el otro script ejecuta el siguiente código: install.packages(&quot;ggplot2&quot;) library(ggplot2) ggplot(cats, aes(x = Sex)) + geom_bar(fill = &quot;orange&quot;, color = &quot;black&quot;) + theme_classic() PAUSA ¿Cómo podemos exportar el gráfico? 1.10 Últimos tips Puedes modificar el zoom de cada panel en RStudio según tus necesidades y preferencias. Lupa Várita mágica Addins Help RMarkdown 1.10.1 Actividad Ejecuta el siguiente código install.packages(&quot;ggThemeAssist&quot;) g &lt;- ggplot(cats, aes(x = Sex)) + geom_bar(fill = &quot;orange&quot;, color = &quot;black&quot;) + theme_classic() + xlab(&quot;Sexo&quot;) + ylab(&quot;Número de Gatos&quot;) + ggtitle(&quot;Gatos&quot;) g A continuación selecciona g, ve a Addins y da click en ggplot Theme Assistant "],["flujos-de-trabajo-con-proyectos-de-rstudio.html", "2 Flujos de trabajo con proyectos de RStudio 2.1 Diapositivas 2.2 ¿Qué es un proyecto de RStudio? 2.3 ¿Cómo generamos un proyecto de RStudio? 2.4 ¿Por qué usar proyectos de RStudio? 2.5 Algunos hacks!", " 2 Flujos de trabajo con proyectos de RStudio Joselyn Chávez 9 de agosto de 2021 div.grey { background-color: #bfbfbf; } div.center { text-align:center; } 2.1 Diapositivas 2.2 ¿Qué es un proyecto de RStudio? Es un archivo especial de R, compatible con RStudio, que al ejecutarlo hará 3 cosas: Abrirá una nueva sesión de RStudio. Establecerá la ubicación del proyecto como tu directorio de trabajo. Establecerá la ubicación del proyecto como la raíz de los archivos. 2.3 ¿Cómo generamos un proyecto de RStudio? 2.3.1 Opción 1: Creando un proyecto en un directorio nuevo. En las opciones de RStudio Ve a File &gt; New project &gt; New Directory &gt; New Project. Asigna un nombre a tu proyecto, sin espacios y sin caracteres especiales. Selecciona la ubicación donde crearás el nuevo directorio. Selecciona la opción Open in New Session. Oprime Create Project. Actividad 1 Genera un proyecto de RStudio llamado ‘nuevodirectorio’ en un directorio nuevo en tus Documentos (~/Documentos). 2.3.2 Opción 2: Creando un proyecto en un directorio existente. Crea un directorio en alguna ubicación conocida de tu computadora. Asigna un nombre a tu directorio, sin espacios y sin caracteres especiales (Este será el nombre de tu proyecto). En las opciones de RStudio ve a File &gt; New project &gt; Existing Directory. Selecciona la ubicación donde previamente creaste el directorio. Selecciona la opción Open in New Session. Oprime Create Project. Actividad 2 Genera una carpeta o directorio llamado ‘directorioprevio’ en tus Documentos (~/Documentos), después genera un proyecto de RStudio usando este folder como base. 2.4 ¿Por qué usar proyectos de RStudio? Te permiten ser más organizado y pasar de tener una ensalada de archivos a tener carpetas para cada sección del análisis. Compartamentalizas tu trabajo al generar un proyecto específico para cada análisis. Te permiten trabajar con varios proyectos a la vez en sesiones independientes de RStudio, cada uno con sus propias variables, directorio de trabajo y archivos. Establece automáticamente tu directorio de trabajo. En lugar de usar setwd() solamente requieres ejecutar el archivo .Rproj para abrir la sesión y trabajar en la ubicación del proyecto. Puedes usar rutas relativas (y estables) a tus archivos, que seguirán funcionando sin importar en dónde se ubique tu proyecto. Facilita el compartir y reproducir tu trabajo. No más rutas al estilo ~/MiComputadora/MiFolder/MiArchivo. Comparte la carpeta completa de tu proyecto con todos los archivos necesarios y usa rutas relativas dentro del Rscript, por ejemplo ./datos. Nos ayuda a establecer colaboraciones y trabajar con plataformas de control de versiones. Actividad 3 Comprueba algunas ventajas de usar proyectos de RStudio. Genera un nuevo proyecto de RStudio llamado ‘miproyecto’, recuerda que existen varias formas para hacerlo. Cierra la sesión y vuelve a abrirla ejecutando desde la terminal open miproyecto.Rproj o dando doble click sobre el archivo miproyecto.Rproj. Evalúa tu directorio de trabajo ejecutando en la consola de RStudio el comando getwd(). Cierra la sesión y mueve toda la carpeta de tu proyecto a otra ubicación. Si lo creaste en Documentos mueve la carpeta al Escritorio o viceversa. Abre nuevamente el proyecto y verifica el directorio de trabajo, ¿Cambió el directorio de trabajo? Sin cerrar este proyecto, abre alguno de los proyectos que generaste previamente (por ejemplo directorioprevio.Rproj), recuerda que puedes seleccionar Open Project in New session 2.5 Algunos hacks! RStudio recuerda los proyectos con los que has trabajado recientemente. Ve a la esquina superior derecha y da click en la flecha junto al nombre de tu proyecto actual. Verás todos los proyectos recientes. Si das click en el nombre de alguno de ellos te abrirá el proyecto en la misma sesión, si das click en el recuadro con flecha blanca te abrirá una nueva sesión con tu proyecto. Crea todos tus proyectos dentro de una carpeta principal y usa el buscador de archivos para acceder a ellos rápidamente. "],["generando-mi-primer-proyecto-de-rstudio.html", "3 Generando mi primer proyecto de RStudio 3.1 Diapositivas 3.2 Buenas prácticas para ordenar tu proyecto 3.3 Utiliza las rutas adecuadas a los archivos 3.4 Compartiendo tus proyectos", " 3 Generando mi primer proyecto de RStudio Joselyn Chávez 9 de agosto de 2021 div.grey { background-color: #bfbfbf; } div.center { text-align: center; } 3.1 Diapositivas 3.2 Buenas prácticas para ordenar tu proyecto Genera carpetas con: Entradas (datos originales y datos filtrados). Procedimientos (Rscripts con el filtrado, manejo de datos, análisis, generación de gráficas). Salidas (Gráficas generadas y resultados). Actividad 1 Descarga la carpeta proyecto_desordenado desde https://bit.ly/cdsb2021_workflows y ordena los archivos en subcarpetas, considera las recomendaciones mencionadas anteriormente. 3.3 Utiliza las rutas adecuadas a los archivos Ahora que has reorganizado tu proyecto, debes usar las rutas relativas para importar y exportar tus archivos en sus directorios correspondientes. Recuerda que la raiz de tu proyecto será el directorio principal. Por ejemplo: tb &lt;- read.table(&quot;datos/mis_datos.txt&quot;, header = TRUE) Actividad 2 Con tu proyecto ordenado, abre el archivo analisis.R y corrige las rutas a los archivos considerando los subdirectorios que creaste. Mejora aún más tu proyecto! Secciona tu código y crea nuevos scripts con cada una de las secciones que detectes en el análisis. 3.4 Compartiendo tus proyectos Una de las ventajas de usar proyectos de RStudio es facilitar la colaboración con otras personas, así como compartir tu código de manera reproducible. Lo más común es utilizar control de versiones, por ejemplo en GitHub o GitLab. Pero comencemos compartiendo nuestro proyecto mediante Drive. Actividad 3 Genera un proyecto en tu computadora que contenga lo siguiente: Un Rscript o Rmd con un pequeño análisis usando datos públicos de R, por ejemplo puedes usar los datos palmperpinguins, gapminder, o los conjuntos de datos en español del paquete datos. Genera al menos un archivo de salida, por ejemplo una gráfica, una tabla, un archivo de texto o un html relacionado con tu análisis. Crea los subdirectorios necesarios para ordernar tu proyecto y verifica que tu Rscript o Rmd contenga las rutas necesarias para leer o escribir estos archivos en las subcarpetas. Intercambien proyectos! Carga tu proyecto completo en el Drive https://bit.ly/cdsb2021_workflows y pídele a tu compañera/o que lo descargue y compruebe que puede ejecutar el análisis en su computadora. "],["paths-seguros.html", "4 PATHs seguros 4.1 Diapositivas 4.2 Actividad 1", " 4 PATHs seguros María Teresa Ortiz 9 de agosto de 2021 4.1 Diapositivas 4.2 Actividad 1 Corre las siguientes instrucciones para descargar el material de la actividad. library(usethis) use_course(&quot;comunidadbioinfo/corrige-rutas&quot;) "],["nombres-de-archivos.html", "5 Nombres de archivos 5.1 Diapositivas", " 5 Nombres de archivos María Teresa Ortiz 9 de agosto de 2021 5.1 Diapositivas "],["introducción-a-git-y-github-desde-terminal.html", "6 Introducción a Git y GitHub desde terminal 6.1 Diapositivas 6.2 Actividad", " 6 Introducción a Git y GitHub desde terminal Mirna Vázquez Rosas-Landa 10 de agosto de 2021 6.1 Diapositivas 6.2 Actividad "],["generando-un-proyecto-colaborativo-con-gitgithub.html", "7 Generando un proyecto colaborativo con Git/GitHub 7.1 Colaborando mediante Git y Git Hub 7.2 Inicio del proyecto 7.3 Inicio de la colaboración 7.4 Actualizar un fork desde el repositorio upstream 7.5 Cambios desde un fork hacia el repositorio upstream", " 7 Generando un proyecto colaborativo con Git/GitHub Aurora Labastida 10 de agosto de 2021 div.color { border-radius: 5px; padding: 20px; margin: 30px 0px 30px;} div.cyan { background-color:#00cccc; } div.orange{ background-color:#e6dbcf;} div.pair { display: flex; flex-direction: row; justify-content: center; text-align:center; padding:0px} div.inside { width: 49%; padding: 0px} div.scroll { max-height: 400px; overflow-y: auto; background: #111111; border-radius:5px; padding: 10px; margin: 30px 0px 30px; color: #999999;} div.alert{color:#0D4848; background-color:transparent} Si aún no nos has dado tu nombre de usuario de GitHub añadelo en: Registro de usuarios de GitHub Esto será necesario para formar equipos durante esta sesión. 7.1 Colaborando mediante Git y Git Hub Git y GitHub son muy útiles para la colaboración, pues permiten compartir copias de los proyectos (repositorios) y mantenerlas sincronizadas entre si. Además, permiten visualizar la historia de los cambio hechos por cada colaborador y evitan que los programadores sobre-escriban sobre los cambios de otro miembro del equipo. Ensayaremos algunos principios de la colaboración con Git y GitHub mediante una serie de ejercicios. 7.2 Inicio del proyecto A tí y a un colaborador les interesa la anatomía de gatos. Deciden colaborar para averiguar si hay diferencias significativas en el peso del cuerpo y del corazón entre gatos hembras y machos. Uno de ustedes iniciará el análisis del cuerpo (equipo body) y el otro el análisis del corazón (equipo heart). Para saber en qué equipo estás: Da click aquí Ve a GitHub y usando tu cuenta crea un nuevo repositorio. Equipo body: el nombre de tu repositorio será body Equipo heart: el nombre tu repositorio será heart Incluye un README.md y una descripción. En tu computadora utiliza la terminal para crear una copia local del repositorio ( Obtén el link a tu repositorio ) Equipo body git clone https://github.com/mi_usuario/body Equipo heart git clone https://github.com/mi_usuario/heart Nota En el contexto de esta clase terminal se refiere al entorno de línea de comandos de tu sistema operativo (alguna distribución de Linux o macOS) y GitHub se refiere al sitio web de GitHub (https://github.com/) o de tu cuenta de GitHub. Abre RStudio y cambia la ruta de trabajo a la de tu repositorio. Para ello usa a setwd (en la consola de RStudio) o el menú de RStudio (ve a Session &gt; Choose working directory &gt; Choose directory…). Añade un primer script de R para analizar los datos del cuerpo o del corazón de gatos. Para ello usa el menú de RStudio (ve a File &gt; New File &gt; R Script). Equipo body: el nombre del script será body.R Equipo heart: el nombre del script será heart.R Usaremos el set de datos cats, incluído en el paquete MASS. En él se listan el sexo (Sex), peso corporal (Bwt) y peso del corazón (Hwt) de varios gatos. library(&quot;MASS&quot;) head(cats,3) ## Sex Bwt Hwt ## 1 F 2 7.0 ## 2 F 2 7.4 ## 3 F 2 9.5 Con la función str se observa que se incluyen tanto Hembras (F) como machos (M). str(cats) ## &#39;data.frame&#39;: 144 obs. of 3 variables: ## $ Sex: Factor w/ 2 levels &quot;F&quot;,&quot;M&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Bwt: num 2 2 2 2.1 2.1 2.1 2.1 2.1 2.1 2.1 ... ## $ Hwt: num 7 7.4 9.5 7.2 7.3 7.6 8.1 8.2 8.3 8.5 ... Contenido del script (ambos equipos) library(&quot;MASS&quot;) # Datos a analizar head(cats) summary(cats) Guarda el script con el nombre antes mencionado. Ahora cuentas con un repositorio en GitHub y con una copia local de dicho repositorio. El repositorio local está configurado para enviar cambios y recibir cambios desde el repositorio original u origin, es decir, el repositorio en GitHub. En la terminal ve a tu repositorio y comparte los cambios con GitHub: Revisa si hay cambios en el arbol de trabajo git status Añade los cambios al siguiente commit. git add * Realiza el commit añadiendo un mensaje. git commit -m &quot;primer script&quot; Enviamos los cambios al GitHub, es decir, al repositorio origin git push 7.3 Inicio de la colaboración Estamos trabajando en nuestro repositorio cuando nuestro colaborador nos pide que ayuda para su proyecto, que también tiene un repositorio de GitHub. Identifica el usuario de GitHub de tu colaborador. Si eres del equipo heart tu colaborador es del equipo body y si eres del equipo body tu colaborador es del equipo heart. Link al repositorio de tu colaborador Un fork de GitHub es una copia del repositorio de un colaborador que podemos administrar en forma independiente. Podemos actualizar el fork con los nuevos cambios del colaborador y sugerir cambios desde nuestro fork a su repositorio. Ve al repositorio de tu colaborador en GitHub Si estás en el equipo body https://github.com/colaborador/heart Si estás en el equipo heart https://github.com/colaborador/body Realiza un fork del repositorio de tu colaborador Figure 7.1: Nota: si eres del equipo heart el nombre del repositorio será body 7.4 Actualizar un fork desde el repositorio upstream Tu colaborador realizó un fork de tu repositorio para apoyarte en el análisis estadístico. Ahora tú sigues añadiendo cambios en tu repositorio. Así pues el fork que creó tu colaborador se irá quedando momentaneamente atrás de tu repositorio. Usando a RStudio añade nuevos cambios a tu repositorio original. Si eres del equipo body añade al script body.R: # Estadísticas del cuerpo por sexo tapply(cats$Bwt,cats$Sex,summary) Si eres del equipo heart añade al script heart.R # Estadísticas del corazon por sexo tapply(cats$Hwt,cats$Sex,summary) Ve a la terminal y envía los cambios a GitHub. Nota sobre el análisis: Ejecuta el script body.R o heart.R. El test estadístico t sugiere que el peso promedio del cuerpo y del corazón es significativamente distinto entre gatos hembras y machos. Realizaste el fork del repositorio de tu colaborador para apoyarlo en el análisis estadístico. Después de ello tu colaborador siguió añadiendo cambios en su repositorio por lo que decides actualizar tu fork con sus cambios. Ve al fork que creaste en GitHub ( Link al fork ). GitHub te indica que el fork se encuentra detrás del repositorio de tu colaborador. Actualízalo con la opción Fetch upstream. Figure 7.2: Nota: Si estás en el equipo heart el fork se llamará body 7.4.1 Sincronización desde la terminal Sigues añadiendo cambios en tu repositorio. Tu colaborador tendrá que seguir sincronizando su fork con tus cambios. En RStudio añade otro cambio a tu repositorio original. Si estás en el equipo body añade al script body.R: # Prueba estadistica t.test(cats$Bwt~cats$Sex) Si estás en el equipo heart añade al script heart.R: # Prueba estadistica t.test(cats$Hwt~cats$Sex) Ve a la terminal y envía los cambios a GitHub. Tu colaborador ha vuelto a hacer cambios en su repositorio. Esta vez decides crear una copia local del fork en tu computadora y actualizarla con los nuevos cambios. Usando la terminal clona el fork que está en tu cuenta de GitHub ( Link al fork ). Si eres del equipo body git clone https://github.com/mi_usuario/heart.git Si eres del equipo heart git clone https://github.com/mi_usuario/body.git Nota En tu cuenta de GitHub se encuentran el repositorio que tú iniciaste (de aquí en adelante tú repositorio) y el fork del repositorio de tu colaborador (de aquí en adelante el fork) y has creado copias locales de ambos. Dichas copias están configuradas para recibir y enviar actualizaciones desde y hacia el repositorio origin. En ambos casos el origin es el repositorio que está en tu cuenta de GitHub. En el caso de la copia local del fork también puedes añadir al repositorio de GitHub de tu colaborador como repositorio upstream (río arriba). De esta forma podrás recibir actualizaciones directamente de dicho repositorio. En la terminal entra al fork Identifica el o los repositorios remotos a los que que está conectada esta copia local del fork. git remote -v Añade eñ repositorio de tu colaborador como upstream ( Link al repositorio de tu colaborador ): Si eres del equipo body git remote add upstream https://github.com/colaborador/heart.git Si eres del equipo heart git remote add upstream https://github.com/colaborador/body.git Observa cómo cambio la configuración de los repositorios remotos. git remote -v Revisa los cambios que ha hecho tu colaborador git fetch upstream git log -p HEAD..FETCH_HEAD Ahora puedes añadir los cambios usando: git merge upstream/main O bien, git pull upstream main Nota que los cambios se añadieron a la copia local del fork, pero no al repositorio origin en GitHub. Para añadir los cambios en origin. git push origin Ahora tu copia del fork, está sincronizada con el repositorio upstream y el repositorio origin. 7.5 Cambios desde un fork hacia el repositorio upstream Tienes planeado trabajar en el fork para añadir una gráfica al proyecto de tu colaborador. 7.5.1 Trabajando con ramas Git y GitHub permiten generar ramas. Cada repositorio tiene una rama principal (main), que muestra la versión principal del proyecto. Los colaboradores pueden generar nuevas ramas, que serán versiones separadas de main y trabajar en ellas sin que main se vea afectada durante el proceso. Ve a la terminal y entra al fork. Observa las ramas actuales del repositorio git branch Crea una nueva rama graph que te servirá para añadir una gráfica al análisis. git branch graph Observa nuevamente las ramas. git branch Cambia a la rama graph. git checkout graph Abre RStudio y establece al fork como directorio de trabajo. Abre el script de R y haz una adición al análisis -Si eres del equipo body abre el script heart.R y añade #Gráficas del peso del corazón por sexo boxplot(Hwt ~ Sex, data = cats) -Si eres del equipo heart abre el script body.R y añade #Gráficas del peso del cuerpo por sexo boxplot(Bwt ~ Sex, data = cats) Nota sobre el análisis: Ejecuta el script body.R o heart.R. Las gráficas muestran una distribución del peso del cuerpo y del corazón distinta para gatos hembras y machos. Guarda los cambios al script en RStudio En la terminal añade los cambios en el fork mediante un commit. Envía los cambios a al repositorio origin, creando una nueva rama. git push origin graph 7.5.2 Abrir un Pull Request Para comenzar este proceso ve al fork que creaste en GitHub ( Link al fork ) Ve al fork en GitHub. Observa que ahora existen dos ramas. Cambia a la rama graph Selecciona la opción Contribute y después Open pull request Nota que has pasado del fork al repositorio upstream (el de tu colaborador). Abre el Pull Request dejando una nota. 7.5.3 Aceptar un Pull Request Tu colaborador ha enviado una contribución desde su fork hacia tu repositorio de GitHub. Ve a tu repositorio para aceptar su Pull Request. ( Link al tu repositorio ) Ve a tu repositorio en GitHub, abre la pestaña Pull Requests y después el Pull Request de tu colaborador En la nueva página selecciona Merge pull requests Ahora utiliza Confirm merge 7.5.4 Sincronización final del fork Tu colaborador ha aceptado tu Pull Request. Tu cotribución ya está en la rama main del repositorio upstream. Ahora debes actualizar la rama main de tu fork con los mismos cambios. En GitHub ve a la la rama main del fork y utiliza a Fetch upstream ( Link al fork ). Ve a la terminal de Linux/Mac y actualiza la copia local del fork. Primero ve a la rama main. git checkout main Y acualiza la rama main con el contenido del repositorio origin. git pull origin main Una vez que tus cambios están añadidos al repositorio main local, origin y upstream puedes eliminar la rama graph Para eliminarla de la copia local del fork git branch -d graph Para eliminarla en el repositorio origin (en GitHub) git push origin --delete graph "],["git-y-github-con-rstudio.html", "8 Git y GitHub con RStudio 8.1 Manual de sobreviviencia con Git Y GitHub en RStudio (en caso de ser necesario) 8.2 Credenciales HTTPS en Cache 8.3 Conectando RStudio con Git y Github. 8.4 GitHub primero, RStudio después… 8.5 RStudio primero y GitHub también", " 8 Git y GitHub con RStudio Erick Cuevas-Fernández 10 de agosto de 2021 div.color { border-radius: 5px; padding: 20px; margin: 30px 0px 30px;} div.red { background-color:#f67155; } div.orange{ background-color:#f0BB51;} div.pair { display: flex; flex-direction: row; justify-content: center; text-align:center; padding:0px} div.inside { width: 49%; padding: 0px} div.scroll { max-height: 400px; overflow-y: auto; background: #111111; border-radius:5px; padding: 10px; margin: 30px 0px 30px; color: #999999;} div.alert{color:#bd475d; background-color:transparent} 8.1 Manual de sobreviviencia con Git Y GitHub en RStudio (en caso de ser necesario) Por cualquier problema con la conexión entre RStudio y Git, siempre ten en cuenta la ubicación de dónde se instaló Git. Puedes usar en la terminal which git (Mac y Linux) O bien usar en la terminal where git (Windows) Recuerda que la terminal (o línea de comandos ó consola ó shell ó bash) es un programa en tu computadora que funciona para correr otros programas. Desde RStudio puedes abrir la terminal, lo cual es muy conveniente si estás trabajando en un proyecto. Puedes abrir una terminal con: Tools &gt; Terminal (abre la terminal dentro del IDE de RStudio) Tools &gt; Shell (abre una terminal externa a RStudio) La recomendación actual de GitHub es usar HTTPS porque es la manera más fácil de configurar y tiene operabilidad en multiples redes y plataformas. Es menos probable que HTTPS sea bloqueado por un firewall. Una conexión HTTPS permite que credential.helper almacene en caché su contraseña. (por tanto puedes configurar tu usuario y contraseña en tu equipo de uso) Es más sencillo acceder a un repositorio desde cualquier lugar, ya que solo necesita los detalles de su cuenta (no se requieren claves SSH) para escribir en el repositorio. Usualmente cuando inicies un proyecto colaborativo con GitHub inicializa el ropositorio con un README. Copia el HTTPS URL para clonar el repositorio en la terminal git clone https://github.com/TU-USUARIO/TU-REPOSITORIO.git. 8.2 Credenciales HTTPS en Cache Puedes crear un token de acceso personal, PAT (PERSONAL ACCESS TOKEN), esa será tu credencial para HTTPS. Es una alternativa al uso de contraseñas para la autenticación en GitHub cuando utilizas la API de GitHub o la línea de comandos. Como precaución de seguridad, GitHub elimina automáticamente los tokens de acceso personales que no se han usado durante un año. OJO PARA FINES DEL CURSO POR AHORA NO GENERAREMOS UN TOKEN, este proceso realizalo cuando tengas planificado donde guardar tu contraseña y trabajes con una computado personal. ¿Cómo crear un token? Ve a tu perfil de GitHub, dale click a la imagen de perfil (usualmente en la esquina superior derecha), y busca la opción de settings ó configuración según sea la configuración de idioma que tengas. Da click a continuación en Developer settings ó Parámetros del desarrollador. En la barra lateral izquierda da click en Tokens de acceso personal. Haz click en Generar un nuevo token. Asígna un nombre descriptivo a tu token. Selecciona los alcances o permisos que deseas otorgarle a este token. Para usar tu token para acceder a repositorios desde la línea de comando, selecciona repo. Finalmente haz click en generar token. Listo, copia y pega tu token en el lugar dónde siempre lo puedas volver a copiar, ya que por razones de seguridad, una vez salgas de la página no podrás volver a ver el token. Nota: Preserva tus tokens de la misma manera que tus contraseñas y no se las reveles a nadie. Cuando trabajes con la API, usa tokens como variables del entorno en lugar de codificarlos de forma rígida en tus programas. Una vez que tengas un token, puedes ingresarlo en lugar de tu contraseña cuando realices operaciones de Git a través de HTTPS. El punto final es que una vez configurada una PAT, varios paquetes de R, incluidos usethis y gh, podrán trabajar con la API de GitHub en su nombre, de forma automática. Por lo tanto, una PAT configurada correctamente significa que todo esto funcionará a la perfección: - Operaciones HTTPS remotas a través de la línea de comando Git y, por lo tanto, a través de RStudio - Operaciones HTTPS remotas a través del paquete gert R y, por lo tanto, usethis - Operaciones de la API de GitHub a través del paquete gh R y, por lo tanto, usethis ¿Cómo crear un token desde R? Puedes ir directamente a la página de GitHub a la parte para generar tu token de acceso personal mediante la siguiente función: usethis::create_github_token() Y con las opciones que se mencionaban anteriormente puedes configurar y crear tu PAT. Si lo que quieres especificar tu PAT en RStudio, las siguientes funciones te serán útiles: library(gitcreds) gitcreds_set() library(credentials) set_github_pat() Para eliminar credenciales utiliza la función credentials::git_credential_forget() 8.2.1 Actividad Ejecuta los códigos PERO no generes para tu PAT por ahora. 8.3 Conectando RStudio con Git y Github. Para lo que sigue a continuación, deberías tener esto: Tener una cuenta en GitHub R y RStudio actualizados Git instalado Saber que desde la terminal puedes hacer push y pull 8.4 GitHub primero, RStudio después… Crea un repositorio en GitHub: mi_repositorio &gt; Public &gt; YES initialize this repository with a README &gt; clicken el gran botón verde “Create repository” En RStudio crea un nuevo proyecto: File &gt; New Project &gt; Version Control &gt; Git. Ahi pega el URL del repositorio https://github.com/mi_usuario/mi_repositorio.git. Da click en Create Project. Esto nos generará los siguientes elementos: Un directorio nuevo Un repositorio Git enlazado a al repositorio de GitHub Un proyecto en RStudio Con este procedimiento ya no es necesario preocuparse por configurar controles remotos Git y rastrear ramas en la línea de comandos. 8.4.1 Actividad Genera un repositorio con el nombre que desees. Y conéctalo a RStudio. Cerciorate de que el archivo README se encuentre en tu nueva carpeta. Usa la función usethis::use_r(\"titulo_de_un_script\") y observa lo que sucede. PAUSA ¿Cómo comento y doy push/pull desde RStudio? 8.4.2 Comentar, pull y push Con la flecha azul podemos hacer pull (RECUERDA HACERLO ANTES DE HACER UN PUSH), y con la flecha verde un push. Para poder comentar y hacer push debemos marcar con una flechita mediante un click en las pequeñas cajas blancas de la columna Staged, damoc click en commit lo cual no abre la siguiente ventana. Volvemos a dar click en commit, y finalizamos con push (flecha verde). 8.4.3 Actividad Usa el código dir.create(\"mis_imagenes\") en la consola de tu sesión de RStudio (la que está vinculada a tu repositorio). Ejecuta el siguiente código quitando los #: data(MASS::cats) # pdf(&quot;mis_imagenes/cats_plot.pdf&quot;) ggplot(cats, aes(x = Sex)) + geom_bar(fill = &quot;orange&quot;, color = &quot;black&quot;) + theme_classic() + xlab(&quot;Sexo&quot;) + ylab(&quot;Número de Gatos&quot;) + ggtitle(&quot;Gatos&quot;) # dev.off() Comenta y da push a los cambios que realizaste en el repositorio. 8.5 RStudio primero y GitHub también Usa uno de los proyectos que hayas generado en las sesiones anteriores, PERO, que no esté enlazado a GitHub. Ahora veremos como conectar un proyecti de R existente con GitHub. Realiza los pasos que hicimos en GitHub primero, RStudio después pero asegurate de crear un repositorio con un nuevo nombre. Y LISTO!! usa un simple ctrl + c, ó mv ó click derecho + copiar ó el método que prefieras para mover o copiar archivos. Copia los archivos de tu antigüo proyecto al proyecto nuevo. Solo haz commit y push y listo, lo que tenía en tu antigüo proyecto ya está enlazado a GitHub. "],["merge-y-conflictos-de-versiones-en-git-y-github.html", "9 Merge y conflictos de versiones en Git y GitHub 9.1 Diapositivas 9.2 Agradecimientos 9.3 Usando git de forma segura 9.4 Commit al infinito 9.5 Viajando en el tiempo 9.6 Reescribiendo la historia 9.7 Reescribiendo la historia 9.8 Rechazo de PUSH 9.9 Rechazo de PUSH 9.10 Rechazo de PUSH &gt; Hagamos PULL 9.11 PULL con cambios locales sin commit 9.12 PULL con conflictos 9.13 Solución con git stash 9.14 Cuando git stash no trae la felicidad 9.15 Merge conflics 9.16 Merge conflics 9.17 Regresando a git stash 9.18 Regresando a git stash 9.19 Qué hacemos si si hicimos commit y PULL no funciona? 9.20 Qué hacemos si si hicimos commit y PULL no funciona? 9.21 PULL con rebase 9.22 PULL con rebase 9.23 Actividad", " 9 Merge y conflictos de versiones en Git y GitHub Alejandra Medina-Rivera 10 de agosto de 2021 9.1 Diapositivas 9.2 Agradecimientos Este documento se basa en “Happy Git with R” de Jenny Bryan, los STAT 545 TAs, Jim Hester https://happygitwithr.com 9.3 Usando git de forma segura Usando commit podemos evitar problemas Cada commit es un pin de seguridad en una escalada Debemos hacer commit LOCAL continuamente LOCAL quiere decir sin PUSH git commit -m &quot;Mensaje que diga que hice&quot; 9.4 Commit al infinito Hacer commit LOCAL es muy bueno pero puede dejar nuestra historia un poco intensa Para eso existe amend no-edit va a dejar el mensaje original del commit git commit -m &quot;Mensaje que diga que hice&quot; git commit --amend --no-edit Cuando hayamos terminado de trabajar podemos cambiar el mensaje y dejar algo más completo git commit --amend --m &quot;ahora que ya terminé puedo dejar algo más completo&quot; git push 9.5 Viajando en el tiempo Estamos trabajando y nos equivocamos y ya nada sirve Podemos volver al último commit donde todo funcionaba! git reset --hard 9.6 Reescribiendo la historia Amend es reescribir la historia de un commit. Es importante no reescribir historias si ya se hizo PUSH Cuando hacemos PUSH alguien de nuestro equipo podría ya haber hecho PULL. Si por algo ya hicimos PUSH tenemos dos opciones: reset a un commit anterior y luego hacer pull git reset --hard HEAD git pull Si estamos super seguros que nadie de nuestro equipo hizo pull de nuestro error, entonces podemos hacer un push force git push --force 9.7 Reescribiendo la historia Repetimos: De verdad no hay que hacer force 9.8 Rechazo de PUSH Un problema común es que intentemos hacer PUSH a nuestro repositorio central y que se rechacen nuestros cambios $ git push To https://github.com/YOU/REPO.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &#39;https://github.com/YOU/REPO.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. -Esto quiere decir que el repositorio central y lo que tenemos local han divergido. 9.9 Rechazo de PUSH -Solución: hacer PULL a local y lidiar con los conflictos -Cómo evitar que estemos pasando por este tipo de situaciones: No trabajar offline demasiado tiempo y hacer commit y PUSH seguido. Hacer PULL de forma continua para evitar divergir. Así si algo divergió el merge será menos doloroso. Trabajo en equipo, comunicación en equipo. Si sabemos qué hacen los demás es más fácil evitar conflictos. Uso de branches, organizar el progreso de nuestro trabajo en equipo en branches hará menos doloroso hacer integración con otras versiones. 9.10 Rechazo de PUSH &gt; Hagamos PULL Inevitable: nos rechazan un PUSH así que debemos hacer PULL Nuestra historia local: A–B–C A–B– Cambios sin commit La historia en el repositorio central: A–B–D Lo que queremos es hacer una fusion 9.11 PULL con cambios locales sin commit -Escenario 1: PULL feliz git pull Cuando no hay sobrelape entre lo que cambió en el repo central y lo que hice local, entonces PULL simplemente va a funcionar, dejando nuestra nueva historia incluyendo C A–B–C–(uncommitted changes) 9.12 PULL con conflictos Si hay sobrelape entre lo que hicimos local y el repo central pull va a fallar $ git pull remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 1), reused 1 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:jennybc/ethel db046b4..2d33a6f master -&gt; origin/master Updating db046b4..2d33a6f error: Your local changes to the following files would be overwritten by merge: foo.R Please commit your changes or stash them before you merge. Aborting Quién me dice cuál es el problema? 9.13 Solución con git stash stash nos permite guardar los cambios locales que no pasamos a commit en un universo medio paralelo $ git stash save Saved working directory and index state WIP on master: db046b4 Merge branch &#39;master&#39;of github.com:jennybc/ethel $ git pull Updating db046b4..2d33a6f Fast-forward foo.R | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) $ git stash pop Auto-merging foo.R On branch master Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foo.R no changes added to commit 9.14 Cuando git stash no trae la felicidad git stash pop Auto-merging foo.R CONFLICT (content): Merge conflict in foo.R 9.15 Merge conflics A veces, no tan a veces también, las cosas no salen bien a la primera Merging (Fusionar) es una de esas cosas Primera regla: NO ENTRAR EN PANICO!!! Revisen el status del repositorio. Qué archivo tiene conflicto? 9.16 Merge conflics Abran ese archivo y busquen los problemas de merge. Es fácil, se ven así: &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:index.html Editen esa sección, dejen una versión final. 9.17 Regresando a git stash Ya tenemos la versión final de nuestro archivo conflictivo Ahora a limpiar un poco el desastre $ git reset $ git reset --mixed Unstaged changes after reset: M foo.R git reset (default: mixed) nos va a regresar al “commit” anterior. PELIGRO: la opción hard de git reset incluso borra todo lo que pasó después del commit. Esto es como rm -f, así que con cuidado! 9.18 Regresando a git stash Por último, debemos dejar el stash que estábamos haciendo $ git stash drop Dropped refs/stash@{0} (7928db50288e9b4d934803b6b451a000fd7242ed) Ya quedó todo listo para continuar 9.19 Qué hacemos si si hicimos commit y PULL no funciona? PULL, fetch/merge -El mejor escenario es que el merge es fácil por que no hay conflictos $ git pull &lt;Se habre un editor de texto para que podamos añadir un mensaje al Merge&gt; Merge made by the &#39;recursive&#39; strategy. README.md | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) 9.20 Qué hacemos si si hicimos commit y PULL no funciona? El escenario donde falla el merge $ git pull Auto-merging foo.R CONFLICT (content): Merge conflict in foo.R Automatic merge failed; fix conflicts and then commit the result. Arreglamos todo como la vez pasada, eligiendo en el archivo la versión que nos gusta y cuando estemos listos add y commit $ git add foo.R $ git commit 9.21 PULL con rebase Pull combinado con su opción rebase hace una historia más limpia. Nos evitamos añadir otro commit consecuencia del merge Es tentador pero peligroso por que los cambios locales se aplicarán sobre los remotos 9.22 PULL con rebase $ git pull --rebase First, rewinding head to replay your work on top of it... Applying: Take max El problema: vamos a acarrear conflictos de merge en el futuro y nuestra historia se reescribe un poco $ git rebase --abort 9.23 Actividad 9.23.1 Probemos nosotres! Vayan a GitHub y creen en repostorio “toxico” Creen un README Clonen este reposotorio a sus computadoras Editen el README en su computadora Ahora editen el READM en el GitHub Traten de hacer pull, qué pasó? Cómo lo arreglamos? 9.23.2 Todo es práctica Y si nada funciona pues volvemos a instalar el repo "],["modificando-los-archivos-de-inicio-de-r.html", "10 Modificando los archivos de inicio de R 10.1 Diapositivas 10.2 ¿Qué son los archivos de inicio? 10.3 Modificando el archivo .Renviron 10.4 Modificando el archivo .Rprofile", " 10 Modificando los archivos de inicio de R Joselyn Chávez 11 de agosto de 2021 div.grey { background-color: #bfbfbf; } div.center { text-align:center; } 10.1 Diapositivas 10.2 ¿Qué son los archivos de inicio? R ofrece una gran diversidad de opciones para personalizar el espacio de trabajo, sin embargo, esta flexibilidad conlleva un alto grado de complejidad. Figure 10.1: R Startup flowchart de Thomas Lin Pedersen Al iniciar R, una serie de procesos complejos se ejecutan tras bambalinas. En general, podemos concentrarnos en dos archivos: El archivo .Renviron contiene las variables del ambiente de trabajo que deberán ser establecidas al iniciar cada sesión. El archivo .Rprofile contiene código de R que será ejecutado al iniciar cada sesión. Estos archivos forman parte de una gran familia de archivos de personalización conocidos como dotfiles o archivos ocultos. Este tipo de archivos suelen contener las instrucciones necesarias para dirigir el comportamiento de diversos programas, en particular aquellos que suelen ejecutarse desde un ambiente de linea de comandos. Muchas personas suelen conservar este tipo de archivos dentro de sus repositorios, por ejemplo en GitHub. Consultar los archivos ocultos de otros desarrolladores puede ser una referencia o fuente de inspiración para conocer todo lo que es posible hacer con estos archivos. Una forma rápida para encontrar este tipo de archivos dentro de los repositorios de GitHub es usando la herramienta de búsqueda y escribir .Rprofile. Antes de comenzar a editar estos archivos, es importante que tengas en cuenta que deben terminar en linea en blanco. Si lo prefieres, puedes marcar esta opción en la configuración de RStudio que asegurará que tus archivos fuente siempre cumplan esta condición. Puedes encontrar más información sobre los archivos de punto en https://dotfiles.github.io/ 10.3 Modificando el archivo .Renviron El archivo .Renviron es útil para configurar cómo se comporta el ambiente de R, por ejemplo, podemos establecer el número de lineas que deseamos almacenar y mostrar en nuestra historia de comandos (history). Para ver todas las variables de tu .Renviron ejecuta este comando: Sys.getenv() NOTA: Cada vez que hagas un cambio en el archivo .Renviron debes guardar el archivo y reiniciar la sesión de RStudio para que los cambios se vean reflejados. Usa el menú principal y selecciona Session &gt; Restart R o el atajo del teclado shift + command + F10 o shift + ctrl + F10. Es importante recordar que las variables que estamos configurando en el archivo .Renviron no son código de R. Estas variables usan un formato similar a los usados en la linea de comandos de shell. 10.3.1 Modificando el historial de la sesión Dale un vistazo a la ventana History en tu sesión de RStudio, ¿Cuántos comandos ves?. Si tu historial está en blanco, escribe algunos comandos sencillos en la consola para que puedas ver el comportamiento de tu History. Puedes ejecutar el comando Sys.getenv() y buscar la variable R_HISTSIZE para conocer el tamaño máximo de tu historial actual. Ahora abre el archivo .Renviron, la forma más sencilla de hacerlo es usando el siguiente comando: usethis::edit_r_environ() Vamos a modificar el tamaño de la historia de comandos a mostrar, escribe ‘R_HISTSIZE=3’ dentro del archivo .Renviron. Guarda los cambios y reinicia la sesión de RStudio. Comienza a escribir algunos comandos sencillos en la consola y observa cuántos comandos se muestran en la ventana History. ¿Notas la diferencia? 10.3.2 Modificando el comportamiento de las funciones Las modificaciones a las variables del archivo .Renviron también nos permiten controlar cómo se va a comportar nuestro entorno de R cuando evaluamos ciertas condiciones y nos permitirá ser más estrictos al evaluar las variables de entrada a nuestro código. Veamos un ejemplo: Actividad 1 Define un vector x &lt;- c(5, -2). Escribe una función que te permita evaluar si los elementos dentro de este vector son positivos o negativos, tomando en cuenta si son menores o mayores a cero. (Pista: usa los condicionales if() y else() ). Recuerda que la estructura básica para escribir una función es: mifuncion &lt;- function(x) { # aquí va el cuerpo de la función } Evalúa los elementos del vector x usando tu función. Observa detenidamente el resultado. Ahora, escribe en tu archivo .Renviron la siguiente variable: R_CHECK_LENGTH_1_CONDITION=true guarda los cambios y no olvides reiniciar tu sesión. Vuelve a ejecutar la evaluación del vector x usando tu función. ¿Qué diferencia notas? 10.3.3 Generando un .Renviron por proyecto Cuando iniciamos una sesión de RStudio se pasa por varios niveles de revisión sobre la configuración de nuestra sesión. Este proceso ocurre muy rápido y la mayoría de los usuarios no necesita revisarlo a profundidad, pero cuando trabajamos en una organización puede sernos útil conocer que el proceso de inicio va del nivel más general (todos los usuarios) hasta el más particular (un sólo usuario o un proyecto en específico) Hasta el momento, las modificaciones al .Renviron las hemos realizado en nuestro usuario general o home de nuestra instalación, pero también podemos generar configuraciones específicas para un proyecto de RStudio. usethis::edit_r_environ() abre el .Renviron de tu usuario. usethis::edit_r_environ(“project”) abre el .Renviron de tu proyecto actual. Vamos a revisar cómo generar un .Renviron para un proyecto: Limpia las configuraciones de tu archivo .Renviron que escribimos hasta ahora. Crea un nuevo proyecto. Observa la lista de archivos dentro de tu proyecto, hasta este punto solamente debe existir el archivo .Rproj. Dentro del proyecto ejecuta el comando usethis::edit_r_environ(“project”) que te abrirá un archivo .Renviron, nota que en la lista de archivos de tu proyecto se ha agregado este archivo de inicio. Actividad 2 Agrega la variable R_CHECK_LENGTH_1_CONDITION=true que usamos anteriormente y vuelve a realizar la prueba de evaluación de números negativos y positivos del vector x. Compara el comportamiento dentro de tu proyecto contra el que tienes en una sesión de RStudio fuera de tu proyecto. Verás que en la sesión general el error no se genera (comportamiento laxo), mientras que dentro de tu proyecto este mensaje de error sí aparece (comportamiento estricto). 10.3.4 Guardando tokens para la conexión con APIs En .Renviron también podemos almacenar información sensible, por ejemplo, las llaves de autenticación para conectar con aplicaciones como GitHub. Esto es particularmente útil para la instalación de paqueterías desde el código fuente que veremos más adelante con detalle. En el GitHub de la CDSB existe un paquete llamado ‘saludo’, pero se encuentra como un repositorio privado. Solamente los colaboradores de este repositorio tienen acceso a él (Si estás inscrito en este taller, te hemos agregado como colaborador). De forma normal, podrías instalar un paquete desde GitHub usando el comando: remotes::install_github(&quot;comunidadbioinfo/saludo&quot;) Intenta ejecutar este comando, seguramente obtendrás un mensaje que dirá que este repositorio no existe, ¿Por qué pasa esto? Esto se debe a que tu ambiente de R no está conectado con tu usuario de GitHub, debemos indicarle nuestras credenciales usando un Token de autenticación. Vamos a tu usuario de GitHub y entra en Settings &gt; Developer settings &gt; Personal access tokens. Da clic en Generate new token. En las opciones ‘Select scopes’ selecciona ‘repo’ y ‘write:packages’. Da clic en ‘Generate token’ y copia el token a tu portapapeles. Ahora abre tu archivo .Renviron y escribe GITHUB_PAT=TuToken (reemplaza la palabra TuToken con la clave que copiaste). Guarda los cambios y reinicia la sesión de R. Vuelve a probar con la instalación del paquete, esta vez el código debe funcionar. Si colocas información sensible dentro del archivo .Renviron y estás trabajando con un repositorio de GitHub, entonces no querrás dejar expuesto este archivo al público. Puedes agregar este archivo en la lista de archivos a ignorar por git, para esto deberás listarlo dentro del archivo .gitignore o puedes utilizar el paquete credentials (disponible en CRAN) que te ayudará a almacenar tu token de autenticación sin dejarlo expuesto en el archivo .Renviron usando credentials::set_github_pat(). 10.4 Modificando el archivo .Rprofile El archivo .Rprofile contiene código de R que será ejecutado cada vez que se inicia una sesión de R. Este código se ejecuta después de leer las configuraciones de nuestro .Renviron pero antes de que podamos escribir código en nuestra sesión. Este archivo se encuentra normalmente en nuestro directorio raíz o home (~/.Rprofile), aunque si lo necesitas puedes asignarle una ubicación diferente asignando una ruta dentro de la variable R_PROFILE_USER en el archivo .Renviron. La forma más sencilla de abrir nuestro archivo .Rprofile es ejecutando el siguiente comando: usethis::edit_r_profile() Algunas configuraciones que se hacen usualmente dentro del .RProfile son: Establecer la ventana de descarga de CRAN. Escribir un mensaje de bienvenida a la sesión. Personalizar el prompt de R. Establecer algunas configuraciones estéticas como el ancho de la pantalla o la forma en que se despliegan las variables numéricas. Cargar paquetes que se usan con mucha frecuencia (de manera MUY cautelosa). Generar sobrenombres o abreviaturas a funciones que usamos frecuentemente. Para ver todas las opciones disponibles a modficar y sus valores actuales usa el comando options() 10.4.1 Modificando la estética de la consola Habrás notado que el prompt de la consola es un símbolo “&gt;” . Si por alguna razón esta apariencia no es de tu agrado, puedes modificarla usando por ejemplo: options(prompt = &quot;&gt;&gt;&gt;&quot;) Guarda los cambios y reinicia la sesión, después debes escribir algo en tu consola para ver reflejado el cambio. Si ejecutas esta función directamente en tu consola en lugar de escribirlo en .Rprofile también verás el efecto, pero solamente se mantendrá mientras estés en la sesión actual, la configuración volverá a su estado por defecto al reiniciar o cerrar la sesión. 10.4.2 Modificando el número de dígitos Ejecuta el comando options() y busca la variable ‘digits’, verás que por defecto es igual a 7. Esto significa que al realizar una operación matemática obtendremos máximo 7 dígitos en la consola. Probablemente sea más cómodo limitarlo a 3 dígitos, vamos a modificarlo. En la consola realiza la operación 1/3 y observa el número de dígitos que se generan. Ahora abre tu archivo .Rprofile usando usethis::edit_r_profile(). Agrega el siguiente código: options(digits=3) Guarda los cambios y reinicia la sesión. Vuelve a realizar la operación 1/3 y observa la diferencia. 10.4.3 Cargando paquetes frecuentes Si eres un amante del tidyverse, es probable que cada uno de tus scripts de R comiencen con library(tidyverse) o al menos con library(dplyr) o library(ggplot2). Para un uso personal, puede ser útil configurar el llamado de algunos paquetes cada vez que inicias sesión. Veamos un ejemplo: Asegúrate de tener instalado el paquete dplyr, si aún no lo tienes instalado puedes hacerlo con install.packages(&quot;dplyr&quot;) Abre el archivo .Rprofile Agrega el código: library(dplyr) dentro del archivo. Guarda los cambios y reinicia la sesión. Notarás que en la consola aparece el mensaje “Attaching package: ‘dplyr’”. 10.4.4 Asignación de sobrenombres a las funciones En ocasiones nos encontramos con funciones que tienen nombres bastante elaborados o que nos cuesta trabajo recordar. Para este fin, podemos asignarles un sobrenombre dentro del .Rprofile que podemos aplicar a cualquier Rscript dentro de la sesión. Veamos un ejemplo: Abre tu archivo .Rprofile usando usethis::edit_r_profile() Reemplacemos la función sum con su nombre en español suma, agrega el siguiente código: suma &lt;- sum Guarda los cambios y reinicia la sesión. Ahora usa la función suma como lo harías al sumar cualquier serie de números con sum(). suma(1,2) Ten presente, que este sobrenombre únicamente va a funcionar para tu usuario o computadora, incluso puede ser usado en un proyecto específico. 10.4.5 Creando mensajes de error personalizados Si necesitas un poco de ánimos para seguir escribiendo tu código, puedes agregar algunos mensajes personalizados de error. Abre el archivo .Rprofile Agrega el siguiente código: options(error= function() cat(&#39; \\\\\\ Sigue intentando! \\n \\\\\\ /\\\\_/\\\\ ( o.o ) &gt; ^ &lt;\\n\\n&#39;)) Guarda los cambios y reinicia la sesión. Ahora generemos un error a propósito, usa la función suma() que creamos hace un momento y dale un valor inesperado (por ejemplo un caracter) y observa el resultado. suma(&#39;a&#39;) 10.4.6 Mensajes de bienvenida Para generar mensajes de bienvenida y/o despedida de tu sesión, usaremos el siguiente código como base dentro de tu .Rprofile: if (interactive()) { .First &lt;- function() { # aquí van los mensajes o las funciones para la bienvenida } .Last &lt;- function() { # aquí van los mensajes o las funciones para la despedida } Agreguemos un mensaje de bienvenida sencillo: Abre tu archivo .Rprofile usando usethis::edit_r_profile() Agrega el siguiente código: if (interactive()) { .First &lt;- function() { print(&quot;Hola!&quot;) } } Guarda los cambios y reinicia la sesión. Ahora verás que aparece el mensaje Hola! en tu consola al inicio de tu sesión. Recuerda que en este archivo usamos código de R, así que podemos llamar a las funciones de los paquetes que tenemos instalados. Por ejemplo, puedes usar la función saludo::saludo() del paquete privado que instalaste previamente para generar saludos aleatorios. Abre tu archivo .Rprofile usando Agrega el siguiente código: if (interactive()) { .First &lt;- function() { print(saludo::saludo()) } } Guarda los cambios y reinicia la sesión un par de veces. Ahora verás que aparece un mensaje aleatorio en tu consola cada vez que inicias la sesión. Si eres amante de los animales, puedes usar el paquete cowsay para generar imágenes de diversos animales usando código ASCII. Puedes instalarlo desde CRAN usando install.packages(&quot;cowsay&quot;) Veamos la lista de animales disponibles usando names(cowsay::animals) ## [1] &quot;cow&quot; &quot;chicken&quot; &quot;chuck&quot; &quot;clippy&quot; &quot;poop&quot; ## [6] &quot;bigcat&quot; &quot;ant&quot; &quot;pumpkin&quot; &quot;ghost&quot; &quot;spider&quot; ## [11] &quot;rabbit&quot; &quot;pig&quot; &quot;snowman&quot; &quot;frog&quot; &quot;hypnotoad&quot; ## [16] &quot;shortcat&quot; &quot;longcat&quot; &quot;fish&quot; &quot;signbunny&quot; &quot;facecat&quot; ## [21] &quot;behindcat&quot; &quot;stretchycat&quot; &quot;anxiouscat&quot; &quot;longtailcat&quot; &quot;cat&quot; ## [26] &quot;trilobite&quot; &quot;shark&quot; &quot;buffalo&quot; &quot;grumpycat&quot; &quot;smallcat&quot; ## [31] &quot;yoda&quot; &quot;mushroom&quot; &quot;endlesshorse&quot; &quot;bat&quot; &quot;bat2&quot; ## [36] &quot;turkey&quot; &quot;monkey&quot; &quot;daemon&quot; &quot;egret&quot; &quot;duckling&quot; ## [41] &quot;duck&quot; &quot;owl&quot; &quot;squirrel&quot; &quot;squirrel2&quot; Para obtener el código ASCII de un conejo o cualquier animal de la lista podemos usar cowsay::animals[&quot;rabbit&quot;] Si eres fan de Star Wars, puedes usar el paquete starwarssay desarrollado por Erick Cuevas para que tus personajes favoritos te den la bienvenida. Puedes instalarlo desde GitHub usando remotes::install_github(&quot;Erickcufe/starwarssay&quot;) Actividad 3 Genera un mensaje de bienvenida y otro de despedida para tu sesión. Consulta la ayuda de la función cowsay::say() para ver ejemplos sobre cómo imprimir los mensajes de bienvenida con este paquete. Consulta la ayuda de la función starwarssay::say() para ver ejemplos sobre cómo imprimir los mensajes de bienvenida con este paquete. 10.4.7 Generando un .Rprofile para cada proyecto Hasta el momento hemos modificado el .Rprofile general de tu usuario, por lo que el código se ejecutará al abrir cualquier sesión de R dentro de tu computadora, pero así como puedes tener un archivo .Renviron para cada proyecto, también puedes tener un .Rprofile específico para cada proyecto de RStudio. Para generar un .Rprofile dentro de un proyecto usa el comando usethis::edit_r_profile(&quot;project&quot;) Actividad 4 Abre alguno de tus proyectos anteriores o crea uno nuevo. Dentro de tu proyecto ejecuta el comando usethis::edit_r_profile(“project”) Realiza algunas configuraciones específicas para ese proyecto, por ejemplo puedes generar un saludo específico o cargar algún paquete que usarás en especial dentro de tus análsis, como ggplot2(). Recuerda guardar los cambios y reiniciar la sesión para que los cambios se vean reflejados. 10.4.8 Reproducibilidad Toma en cuenta que las configuraciones que hagas en tu .Rprofile solamente funcionarán dentro de tu usuario y computadora. Normalmente, en este archivo se incluye código que no afecta el comportamiento de un análisis, por lo que debes tener especial cuidado si cargas paquetes de análisis de datos como dplyr o ggplot2. Mantén presente que si compartes tu código es probable que las funciones de estos paquetes no funcionen en otra computadora, a menos que los llames de forma explícita dentro de tu código. Como alternativa, puedes generar un archivo .Rprofile específico del proyecto donde indiques todas las configuraciones requeridas para que el código funcione. Recuerda compartir este archivo dentro de tu repositorio de GitHub o al usar otro medio para compartir tu proyecto. "],["keynote-código-legible-en-r-6-consejos-simples-y-prácticos-para-escribir-mejor-código.html", "11 Keynote Código legible en R: 6 consejos simples y prácticos para escribir mejor código 11.1 Diapositivas", " 11 Keynote Código legible en R: 6 consejos simples y prácticos para escribir mejor código Ángel Escalante 11 de agosto de 2021 11.1 Diapositivas "],["mantenimiento-del-espacio-de-trabajo-en-r.html", "12 Mantenimiento del espacio de trabajo en R 12.1 Diapositivas 12.2 Exploremos tu instalación de R 12.3 ¿Cómo sabemos qué paquetes tenemos instalados? 12.4 ¿Cómo mantenemos actualizados nuestros paquetes? 12.5 Instalando una versión anterior de un paquete 12.6 Mantenimiento de paqueterías entre versiones de R", " 12 Mantenimiento del espacio de trabajo en R Joselyn Chávez 11 de agosto de 2021 div.grey { background-color: #bfbfbf; } div.center { text-align:center; } 12.1 Diapositivas 12.2 Exploremos tu instalación de R Los paquetes en R son la unidad natural para distribuir código. Actualmente, R base contiene alrededor de 14 paquetes de base y 15 paquetes recomendados en todas sus distribuciones. El repositorio CRAN contiene ~ 18K paquetes que pueden ser instalados usando install.packages(“nombre_del_paquete”) Por otro lado, Bioconductor contiene más de 2K paquetes de software, alrededor de 1000 paquetes de anotación, 400 de datos experimentales y 30 de flujos de trabajo. Para instalar paquetes desde Bioconductor necesitamos el paquete BiocManager: BiocManager::install(&quot;Biostrings&quot;) Notarás que al instalar un paquete siempre aparece un mensaje mencionando la ruta donde el paquete será instalado. Por defecto toda la instalación de R se genera dentro de un directorio que R asigna de forma automática, cuya ruta podemos encontrar con .Library Adicionalmente, existe una ruta donde R busca la disponibilidad de paqueterías instaladas. Esta ruta se actualiza con cada nueva versión de R. Podemos conocer o modificar esta ruta usando .libPaths() Nota que esta ruta contiene la versión de R que tienes instalada, por ejemplo 4.1 12.3 ¿Cómo sabemos qué paquetes tenemos instalados? Si estás en RStudio puedes ir a la ventana Packages o usar el comando installed.packages() Nota que este resultado muestra las propiedades del paquete, como la ruta donde se encuentra instalado, la versión del paquete, sus dependencias, la versión de R en que fue construida, entre otras. Actividad 1 Aprovechemos las funciones de dplyr para analizar tus paquetes instalados. ¿Cuántos paquetes de tu instalación necesitan compilación? ¿Todos tus paquetes se construyeron en la misma versión de R? ¿Cuántos de los paquetes son de R base y cuántos son recomendados? 12.4 ¿Cómo mantenemos actualizados nuestros paquetes? Continuamente los paquetes tienen actualizaciones mejorando el código, agregando funciones o solucionando problemas de código. 12.4.1 Actualización de paquetes desde CRAN Si te encuentras en RStudio, puedes ir a la ventana Packages &gt; Update y seleccionar los paquetes que deseas actualizar. Si te encuentras trabajando en la consola y deseas obtener una lista de los paquetes que tienen una actualización disponible puedes usar el comando old.packages() Para actualizar un paquete en específico desde la consola puedes instalar nuevamente el paquete con install.packages(&quot;pkgname&quot;) O usar el paquete devtools devtools::update_packages(&quot;pkgname&quot;) Nota que las instrucciones anteriores se suelen usar para actualizar uno o algunos paquetes, pero si deseas actualizar todos los paquetes a la vez puedes usar el comando devtools::update_packages(TRUE) 12.4.2 Actualización de paquetes desde Bioconductor Puedes conocer cuáles paquetes tienen una actualización disponible en Bioconductor con el comando BiocManager::valid() Nota que este comando además te proporcionará el comando necesario para instalar los paquetes que requieren actualización. Para instalar las actualizaciones basta con re-instalar el paquete con BiocManager::install(&quot;pkgname&quot;) O puedes instalar todos los paquetes que requieran actualización con BiocManager::install() Actividad 2 Revisa si tus paquetes se encuentran actualizados, usa algunas de las opciones que revisamos anteriormente. Si tienes paquetes que requieran actualizaciones, usa alguna de las opciones y actualiza un paquete. Verifica que después de la actualización se haya eliminado de la lista de paquetes que requieren actualización. 12.5 Instalando una versión anterior de un paquete En algunos casos necesitaremos instalar una versión anterior de algún paquete, por ejemplo para reproducir un análisis que se realizó hace tiempo o solucionar un problema de código. Primero debes conocer el número de versiones anteriores del paquete. Para las paqueterías de CRAN, dirígete a la página del paquete, entra a la sección ‘Old sources’ y selecciona la versión que deseas instalar. Después usa devtools para instalar esa versión en específico devtools::install_version(&quot;devtools&quot;, &quot;1.13.6&quot;) Revisa la versión que tienes instalada actualmente packageVersion(&quot;devtools&quot;) Instala la versión anterior que desees devtools::install_version(&quot;devtools&quot;, &quot;2.0.0&quot;) Verifica la versión ahora packageVersion(&quot;devtools&quot;) Actividad 3 Practiquemos la instalación de versiones anteriores de paquetes y su actualización. Revisa qué versión de ggplot2 tienes instalada. Busca la página de ggplot2 en CRAN y elige alguna versión anterior. Instala alguna de las versiones anteriores. Verifica que se haya instalado la versión que deseabas. Vuelve a actualizar el paquete. Verifica que se haya actualizado a la última versión disponible. 12.6 Mantenimiento de paqueterías entre versiones de R Cuando instalamos una actualización menor de R (por ejemplo si tenemos instalada la versión 3.5.0 y actualizamos a la versión 3.5.1) la instalación de nuestras paqueterías se conserva en el mismo directorio y no es necesario volver a instalarlas. Por el contrario, cuando realizamos actualizaciones grandes de R (por ejemplo de 3.5.3 a 3.6.0 o de 3.6.1 a 4.0.0) la ruta de instalación de nuestras paqueterías cambiará y por ello es posible que necesitemos instalarlas nuevamente. Si sueles instalar un gran número de paqueterías pero no las usas frecuentemente, este cambio de ruta de instalación puede servir para reconsiderar cuáles paqueterías relamente necesitas volver a instalar. Sin embargo, si tienes un gran número de paqueterías que deseas conservar entre actualizaciones de R, existe una solución. Una modificación interesante que podemos hacer dentro de .Renviron es seleccionar la ubicación donde serán instaladas las paqueterías de R usando la variable R_LIBS_USER. Antes de modificar esta variable, veamos cómo se encuentra tu configuración actual. Ejecuta el siguiente comando para ver la ruta que por defecto R selecciona para instalar las paqueterías: Sys.getenv(&quot;R_LIBS_USER&quot;) ## [1] &quot;~/Library/R/x86_64/4.1/library&quot; Si te encuentras trabajando en un sistema operativo OS/Mac, tu ruta se verá similar a R_LIBS_USER=~/Library/R/%v/library. Si te encuentras trabajando en Windows es muy probable que tu ruta se vea así: R_LIBS_USER=~/R/win-library/x.y Nota que la ruta menciona la versión de R que tienes instalada, en mi caso es la versión 4.1. Mantener esto en mente es importante porque cuando hagamos una actualización en el futuro, por ejemplo a R 4.2, esta ruta va cambiar. Suponiendo que estás por instalar la futura versión de R, vamos a crear un directorio para instalar las paqueterías que corresponderán a esa versión. Crea un directorio con el número de versión que instalarás, usando el comando: fs::dir_create(&quot;~/Library/R/4.2/library&quot;) Abre tu archivo .Renviron. Agrega la variable R_LIBS_USER y la ruta al directorio que acabas de crear. Usa R_LIBS_USER=~/Library/R/4.2/library para Mac o R_LIBS_USER=~/R/win-library/4.2 para Windows. Guarda los cambios y reinicia la sesión. Ahora podemos instalar paquetes en este directorio. Instala el paquete dplyr usando el comando install.packages(&quot;dplyr&quot;) Nota que en el mensaje de instalación se menciona la ruta donde está realizando la instalación. Verifica que dplyr se instaló en el nuevo directorio, usa el comando installed.packages(&quot;mi-nuevo-directorio&quot;) %&gt;% as_tibble() %&gt;% View() Ahora puedes transferir todos los paquete que tienes instalados en tu versión actual y preparar el directorio que usará tu próxima versión de R. Si deseas mantener todos los paquetes que tienes instalados actualmente, es recomendable guardar la lista de paquetes en una variable antes de cambiar de directorio de instalación y usarla dentro de los argumentos de tu comando de instalación. Reestablece el directorio de instalación que modificaste en el .Renviron. Genera la lista de paquetes instalados y guárdala en una variable pkgs &lt;- installed.packages() %&gt;% as_tibble() Dale un vistazo al contenido de esta variable. Modifica el directorio de instalación en .Renviron. Instala los paquetes enlistados en pkgs. install.packages(pkgs$Package) Como alternativa, puedes usar el argumento lib de la función install.packages para indicar el directorio donde se instalarán estas paqueterías. De esta forma no es necesario modificar el .Renviron. install.packages(pkgs$Package, lib = &quot;~/Library/R/4.2/library&quot;) Toma en cuenta que si tienes un gran número de paquetes enlistados en pkgs, este comando tardará un tiempo en completarse. Si solamente deseas seleccionar algunos paquetes, puedes usar filtros o selección de lineas ya sea con corchetes df[ ] o con las funciones de dplyr. pkgs$Package[445] ## [1] &quot;xaringan&quot; install.packages(pkgs$Package[445], lib = &quot;~/Library/R/4.2/library&quot;) Finalmente, revisa si los paquetes que instalaste se encuentran en la nueva ubicación. installed.packages(&quot;~/Library/R/4.2/library&quot;) %&gt;% as_tibble() %&gt;% View() Actividad 4 Si aún no lo has hecho, genera un directorio para instalar paqueterías en una versión superior a la que tienes instalada. Enlista las paqueterías que tienes instaladas actualmente y guárdalas en una variable en formato tibble(). Dale un vistazo a tu lista de paqueterías y selecciona alguna o algunas de ellas. Instala estas paqueterías en el directorio correspondiente a la versión superior de R. Asegúrate que se encuentran listadas en el nuevo directorio. Si deseas consultar más detalles sobre mantenimiento de nuestro ambiente de R puedes ir al siguiente link en inglés: https://rstats.wtf/maintaining-r.html "],["instalación-de-paqueterías-desde-código-fuente.html", "13 Instalación de paqueterías desde código fuente 13.1 Diapositivas 13.2 Actividad", " 13 Instalación de paqueterías desde código fuente Joselyn Chávez 11 de agosto de 2021 13.1 Diapositivas 13.2 Actividad "],["introducción-a-shiny.html", "14 Introducción a Shiny 14.1 Diapositivas 14.2 ¿Qué es y para qué me sirve Shiny? 14.3 La estructura canónica de Shiny 14.4 La Interfaz de Usuario (UI)", " 14 Introducción a Shiny Erick Cuevas-Fernández 12 de agosto de 2021 14.1 Diapositivas 14.2 ¿Qué es y para qué me sirve Shiny? Este paquete fue creado en 2012 por RStudio para desarrollar aplicaciones Web con el uso de R. Shiny es un paquete de R que nos permite generar módulos de mando web interactivos, crear interfaces para algoritmos o bien manipular en tiempo real tablas de datos y gráficos a través de controles de HTML. Para instalarlo puedes usar los siguientes códigos: install.packages(&quot;shiny&quot;) if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;shiny&quot;, &quot;rstudio&quot;) Mediante esta paquetería podemos personalizar nuestra creación de forma sencilla con sintaxis HTML, CSS o Javascript. Pero aún así solo se requieren conocimientos de R para emplear Shiny. 14.3 La estructura canónica de Shiny Toda aplicación web de Shiny tendrá la misma estructura, dos bloques de códigos de R: ui: genera una interfaz de usuario server: contiene las instrucciones que la computadora necesita para crear la app. La estructura de código de una app Shiny se vería del siguiente modo: library(shiny) ui &lt;- fluidPage( xxxxInput(), xxxxOutput() ) server &lt;- function(input, output) { Codigo de R } shinyApp(ui = ui, server = server) En RStudio puedes generar una nueva app con este molde de código mediante los siguientes pasos: Crea un nuevo directorio y un archivo app.R que contenga una aplicación básica en un solo paso haciendo clic en Archivo | Nuevo proyecto, luego selecciona Nuevo directorio y Shiny Web Application. Si ya has creado el archivo app.R, puedes agregar rápidamente el texto estándar de la aplicación escribiendo “shinyapp” y presionando Shift + Tab. También puedes hacer dos scripts por separado, ui.R y server.R y ejecutar ambos en la app.R con shinyApp(ui = ui.R, server = server.R). Para que la app esté completa necesitas solo 4 cosas en tu app.R: Cargar la paquetería de Shiny con library(shiny) Definir la interfaz de usuario, la web HTML con la que interactúan quienes ocuparán la app. Es decir, definir la ui. Especificar el comportamiento de nuestra aplicación definiendo una función de server. Ejecutar shinyApp(ui, server) para construir e iniciar una Shiny app. 14.3.1 Actividad Genera un archivo app.R listo para hacer una Shiny app. Puedes generar solo un app.R y posteriormente escribir en la consola “shinyapp” y presionar Shift + Tab 14.4 La Interfaz de Usuario (UI) Shiny por default usa bootstrap (lo cual no tiene nada que ver con el método estadístico bootstrap). Esto es un marco de trabajo de HTML, CSS y Javascript más popular para desarrollar sitios web receptivos. OJO: si sabes usar HTML puedes usar todos los tags en Shiny. Puedes consultar estos tags con la siguiente función: shiny::tags names(shiny::tags) "],["mi-primera-aplicación-shinyr.html", "15 Mi primera aplicación ShinyR 15.1 Diapositivas 15.2 Actividad", " 15 Mi primera aplicación ShinyR Alejandro Reyes 12 de agosto de 2021 15.1 Diapositivas 15.2 Actividad "],["proyecto-en-equipo.html", "16 Proyecto en equipo 16.1 Actividad", " 16 Proyecto en equipo Alejandro Reyes, Erick Cuevas-Fernández y Joselyn Chávez 12 de agosto de 2021 16.1 Actividad "],["keynote-aplicaciones-shinyr-en-la-vida-diaria.html", "17 Keynote: Aplicaciones ShinyR en la vida diaria 17.1 Diapositivas", " 17 Keynote: Aplicaciones ShinyR en la vida diaria Alejandro Ponce 13 de agosto de 2021 17.1 Diapositivas "],["presentación-de-proyectos.html", "18 Presentación de proyectos 18.1 Proyectos", " 18 Presentación de proyectos 13 de agosto de 2021 18.1 Proyectos Proyecto 1: Proyecto 2: Proyecto 3: "]]
